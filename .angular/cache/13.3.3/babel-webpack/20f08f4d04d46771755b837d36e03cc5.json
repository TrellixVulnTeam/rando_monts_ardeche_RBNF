{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Http } from '@capacitor-community/http';\nimport { ZipPlugin } from 'capacitor-zip';\nimport { Capacitor } from '@capacitor/core';\nimport { Filesystem, Directory } from '@capacitor/filesystem';\nimport { Storage } from '@capacitor/storage';\nimport { BehaviorSubject, from, throwError, of, forkJoin } from 'rxjs';\nimport { catchError, map, mergeMap, tap, delay, concatAll, switchMapTo, share, count, scan, withLatestFrom, concatMap } from 'rxjs/operators';\nimport { cloneDeep } from 'lodash';\nimport { environment } from '@env/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ionic/angular\";\nimport * as i2 from \"@app/services/filter-treks/filter-treks.service\";\nimport * as i3 from \"@app/services/online-treks/online-treks.service\";\nexport let OfflineTreksService = /*#__PURE__*/(() => {\n  class OfflineTreksService {\n    constructor(platform, filterTreks, onlineTreksService) {\n      this.platform = platform;\n      this.filterTreks = filterTreks;\n      this.onlineTreksService = onlineTreksService;\n      this.offline = false;\n      this.treks$ = new BehaviorSubject(null);\n      this.currentProgressDownload$ = new BehaviorSubject(0);\n      this.baseUrl = environment.onlineBaseUrl;\n      this.commonMediaContentLength = 0;\n      this.trekContentLength = 0;\n      this.commonMediaBytes = 0;\n      this.trekBytes = 0;\n      this.isMobile = this.platform.is('ios') || this.platform.is('android');\n      this.filteredTreks$ = this.filterTreks.getFilteredTreks(this.treks$);\n      this.getTreks().subscribe(treks => {\n        this.treks$.next(treks);\n      });\n    }\n\n    getTrekImageSrc(trek, picture) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (picture || trek.properties.first_picture) {\n          const imgPath = !!picture ? picture.url : trek.properties.first_picture.url;\n\n          if (this.isMobile) {\n            const imgUri = yield Filesystem.getUri({\n              directory: Directory.Data,\n              path: `offline/${imgPath}`\n            });\n            return Capacitor.convertFileSrc(imgUri.uri);\n          } else {\n            return 'offline/';\n          }\n        }\n\n        return 'offline/';\n      });\n    }\n\n    getCommonImgSrc() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.isMobile) {\n          const imgUri = yield Filesystem.getUri({\n            directory: Directory.Data,\n            path: `offline`\n          });\n          return Capacitor.convertFileSrc(imgUri.uri);\n        } else {\n          return this.baseUrl;\n        }\n      });\n    }\n\n    getTreksUrl() {\n      return '/tabs/treks-offline';\n    }\n\n    getTrekDetailsUrl(trekId, parentId) {\n      return !parentId ? `/trek-details-offline/${trekId}` : `/trek-details-offline/${parentId}/${trekId}`;\n    }\n\n    getTrekMapUrl(trekId, parentId) {\n      return !parentId ? `/map-offline/${trekId}` : `/map-offline/${parentId}/${trekId}`;\n    }\n\n    getTreksMapUrl() {\n      return `/treks-offline-map/`;\n    }\n\n    getTreks() {\n      const emptyTreks = {\n        type: 'FeatureCollection',\n        name: 'OFFLINE-TREKS',\n        features: []\n      };\n      return from(Storage.get({\n        key: 'offline-treks'\n      })).pipe(map(({\n        value\n      }) => JSON.parse(value)), map(treks => !!treks ? treks : emptyTreks));\n    }\n\n    createNewProgressStream() {\n      this.currentProgressDownload$.next(0);\n    }\n\n    willDownloadCommonMedia() {\n      return this.treks$.value && this.treks$.value.features.length === 0;\n    }\n\n    saveTrek(simpleTrek, fullTrek, pois, touristicContents) {\n      this.commonMediaContentLength = 0;\n      this.trekContentLength = 0;\n      this.commonMediaBytes = 0;\n      this.trekBytes = 0;\n      const trekId = simpleTrek.properties.id;\n      const newTreks = cloneDeep(this.treks$.getValue());\n      newTreks.features = [...newTreks.features.filter(feature => feature.properties.id !== trekId)];\n      newTreks.features.push(simpleTrek);\n      this.treks$.next(newTreks);\n      const tasks = [from(Filesystem.mkdir({\n        path: 'zip',\n        directory: Directory.Data\n      }).catch(() => true)), from(Filesystem.mkdir({\n        path: 'offline',\n        directory: Directory.Data\n      }).catch(() => true))];\n\n      if (this.isMobile) {\n        if (this.treks$.value && this.treks$.value.features.length === 1) {\n          tasks.push(this.saveCommonMedia());\n        }\n\n        tasks.push(this.saveMediaForTrek(trekId));\n      } else {\n        tasks.push(this.fakeMediaDl());\n      }\n\n      tasks.push(from(Storage.set({\n        key: 'offline-treks',\n        value: JSON.stringify(newTreks)\n      })), from(Storage.set({\n        key: `trek-${trekId}`,\n        value: JSON.stringify(fullTrek)\n      })), from(Storage.set({\n        key: `pois-trek-${trekId}`,\n        value: JSON.stringify(pois)\n      })), from(Storage.set({\n        key: `touristicContents-trek-${trekId}`,\n        value: JSON.stringify(touristicContents)\n      })));\n\n      if (fullTrek.properties.children && fullTrek.properties.children.features && fullTrek.properties.children.features.length > 0) {\n        fullTrek.properties.children.features.forEach(children => {\n          tasks.push(this.onlineTreksService.getTrekById(children.properties.id, trekId).pipe(map(childrenJson => {\n            return from(Storage.set({\n              key: `trek-${trekId}-${children.properties.id}`,\n              value: JSON.stringify(childrenJson)\n            }));\n          })));\n          tasks.push(this.onlineTreksService.getPoisForTrekById(children.properties.id, trekId).pipe(map(childrenJson => {\n            return from(Storage.set({\n              key: `pois-trek-${trekId}-${children.properties.id}`,\n              value: JSON.stringify(childrenJson)\n            }));\n          })));\n          tasks.push(this.onlineTreksService.getTouristicContentsForTrekById(children.properties.id, trekId).pipe(map(childrenJson => {\n            return from(Storage.set({\n              key: `touristicContents-trek-${trekId}-${children.properties.id}`,\n              value: JSON.stringify(childrenJson)\n            }));\n          })));\n        });\n      }\n\n      return forkJoin(tasks).pipe(map(() => {\n        return true;\n      }), catchError(() => {\n        this.removeTrek(trekId, false);\n        return throwError(false);\n      }));\n    }\n\n    fakeMediaDl() {\n      const requestOne = of(1).pipe(delay(1000));\n      const requestTwo = of(2).pipe(delay(1000));\n      const requestThree = of(3).pipe(delay(1000));\n      const requestFour = of(4).pipe(delay(1000));\n      const requestFive = of(5).pipe(delay(1000));\n      const observables = [requestOne, requestTwo, requestThree, requestFour, requestFive];\n      const array$ = from(observables);\n      const requests$ = array$.pipe(concatAll());\n      const progress$ = of(true).pipe(switchMapTo(requests$), share());\n      const count$ = array$.pipe(count());\n      const ratio$ = progress$.pipe(scan(current => current + 1, 0), withLatestFrom(count$, (current, nb) => current / nb));\n      of(true).pipe(switchMapTo(ratio$)).subscribe(currentProgress => {\n        this.currentProgressDownload$.next(currentProgress);\n      });\n      return of(true).pipe(delay(6000));\n    }\n\n    updateProgress() {\n      const currentProgress = (this.commonMediaBytes + this.trekBytes) / (this.commonMediaContentLength + this.trekContentLength);\n      this.currentProgressDownload$.next(currentProgress);\n    }\n\n    saveCommonMedia() {\n      Http.addListener('progress', e => {\n        if (!this.commonMediaContentLength) {\n          this.commonMediaContentLength = e.contentLength;\n        }\n\n        this.commonMediaBytes = e.bytes;\n        this.updateProgress();\n      });\n      const offlineZipDownloadUrl = `${this.baseUrl}/global.zip`;\n      const options = {\n        url: offlineZipDownloadUrl,\n        filePath: `zip/global.zip`,\n        fileDirectory: Directory.Data,\n        method: 'GET',\n        progress: true\n      };\n      let source;\n      return from(Http.downloadFile(options)).pipe(tap(result => {\n        source = result.path;\n      }), mergeMap(() => {\n        return from(Filesystem.getUri({\n          path: 'offline',\n          directory: Directory.Data\n        }));\n      }), mergeMap(destination => {\n        return new Promise(resolve => {\n          from(ZipPlugin.unZip({\n            source,\n            destination: destination.uri\n          }, progress => {\n            if (progress.completed) {\n              Filesystem.deleteFile({\n                path: `zip/global.zip`,\n                directory: Directory.Data\n              });\n              resolve(true);\n            }\n          }));\n        });\n      }));\n    }\n\n    saveMediaForTrek(trekId) {\n      if (this.treks$.value && this.treks$.value.features.length === 1) {\n        Http.removeAllListeners();\n      }\n\n      Http.addListener('progress', e => {\n        if (!this.trekContentLength) {\n          this.trekContentLength = e.contentLength;\n        }\n\n        this.trekBytes = e.bytes;\n        this.updateProgress();\n      });\n      const offlineZipDownloadUrl = `${this.baseUrl}/${trekId}.zip`;\n      const options = {\n        url: offlineZipDownloadUrl,\n        filePath: `zip/${trekId}.zip`,\n        fileDirectory: Directory.Data,\n        method: 'GET',\n        progress: true\n      };\n      let source;\n      return from(Http.downloadFile(options)).pipe(tap(result => {\n        source = result.path;\n      }), mergeMap(() => {\n        return from(Filesystem.getUri({\n          path: 'offline',\n          directory: Directory.Data\n        }));\n      }), mergeMap(destination => {\n        return new Promise(resolve => {\n          from(ZipPlugin.unZip({\n            source,\n            destination: destination.uri\n          }, progress => {\n            if (progress.completed) {\n              Filesystem.deleteFile({\n                path: `zip/${trekId}.zip`,\n                directory: Directory.Data\n              });\n              resolve(true);\n            }\n          }));\n        });\n      }));\n    }\n\n    removeTrek(trekId, withMedia) {\n      const treks = cloneDeep(this.treks$.value);\n      treks.features = [...treks.features.filter(feature => feature.properties.id !== trekId)];\n      this.treks$.next(treks);\n      const tasks = [];\n      tasks.push(from(Storage.set({\n        key: 'offline-treks',\n        value: JSON.stringify(treks)\n      })));\n      tasks.push(from(Storage.remove({\n        key: `pois-trek-${trekId}`\n      })));\n      tasks.push(from(Storage.remove({\n        key: `touristicContents-trek-${trekId}`\n      })));\n      let stream = forkJoin(tasks).pipe(map(() => true));\n\n      if (this.isMobile && withMedia) {\n        if (this.treks$.value.features.length === 0) {\n          stream = stream.pipe(mergeMap(() => this.removeOfflineData()));\n        } else {\n          stream = stream.pipe(mergeMap(() => this.removeTrekMedia(trekId)));\n        }\n      }\n\n      stream = stream.pipe(mergeMap(() => from(Storage.get({\n        key: `trek-${trekId}`\n      }))));\n      stream = stream.pipe(concatMap(jsonTrek => {\n        const trek = JSON.parse(jsonTrek.value);\n\n        if (trek.properties.children && trek.properties.children.features.length > 0) {\n          const childrenToRemove = [];\n          trek.properties.children.features.forEach(children => {\n            childrenToRemove.push(from(Storage.remove({\n              key: `trek-${trekId}-${children.properties.id}`\n            })));\n            childrenToRemove.push(from(Storage.remove({\n              key: `pois-trek-${trekId}-${children.properties.id}`\n            })));\n            childrenToRemove.push(from(Storage.remove({\n              key: `touristicContents-trek-${trekId}-${children.properties.id}`\n            })));\n          });\n          return childrenToRemove;\n        } else {\n          return of(true);\n        }\n      }));\n      stream = stream.pipe(mergeMap(() => {\n        return from(Storage.remove({\n          key: `trek-${trekId}`\n        }));\n      }));\n      stream = stream.pipe(catchError(() => throwError(false)));\n      return stream;\n    }\n\n    removeTrekMedia(trekId) {\n      return from(Filesystem.rmdir({\n        directory: Directory.Data,\n        path: `offline/${trekId}`,\n        recursive: true\n      })).pipe(map(() => true));\n    }\n\n    removeOfflineData() {\n      return from(Filesystem.rmdir({\n        directory: Directory.Data,\n        path: `offline`,\n        recursive: true\n      })).pipe(map(() => true));\n    }\n\n    getTrekById(trekId, parentId) {\n      if (parentId) {\n        return from(Storage.get({\n          key: `trek-${parentId}-${trekId}`\n        })).pipe(map(({\n          value\n        }) => JSON.parse(value)));\n      } else {\n        return from(Storage.get({\n          key: `trek-${trekId}`\n        })).pipe(map(({\n          value\n        }) => JSON.parse(value)));\n      }\n    }\n\n    getPoisForTrekById(trekId, parentId) {\n      const path = parentId ? `pois-trek-${parentId}-${trekId}` : `pois-trek-${trekId}`;\n      return from(Storage.get({\n        key: path\n      })).pipe(map(({\n        value\n      }) => JSON.parse(value)), map(pois => ({\n        type: 'FeatureCollection',\n        features: pois ? pois : []\n      })));\n    }\n\n    getTouristicContentsForTrekById(trekId, parentId) {\n      const path = parentId ? `touristicContents-trek-${parentId}-${trekId}` : `touristicContents-trek-${trekId}`;\n      return from(Storage.get({\n        key: path\n      })).pipe(map(({\n        value\n      }) => JSON.parse(value)));\n    }\n\n    getTouristicEventsForTrekById(trekId, parentId) {\n      const path = parentId ? `pois-trek-${parentId}-${trekId}` : `pois-trek-${trekId}`;\n      return from(Storage.get({\n        key: path\n      })).pipe(map(({\n        value\n      }) => JSON.parse(value)), map(TouristicEventsItems => ({\n        type: 'FeatureCollection',\n        features: TouristicEventsItems ? TouristicEventsItems : []\n      })));\n    }\n\n    getMapConfigForTrekById(trek, isOffline) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let mapConfig;\n\n        if (isOffline && this.isMobile) {\n          mapConfig = Object.assign(Object.assign({}, cloneDeep(environment.offlineMapConfig)), {\n            zoom: environment.trekZoom.zoom\n          });\n\n          if (mapConfig.style && typeof mapConfig.style !== 'string' && mapConfig.style.sources) {\n            mapConfig.style.sources['tiles-background'].tiles[0] = `${Capacitor.convertFileSrc((yield Filesystem.getUri({\n              path: 'offline',\n              directory: Directory.Data\n            })).uri)}/tiles/{z}/{x}/{y}.png`;\n\n            if (mapConfig.style.layers) {\n              mapConfig.style.sources['tiles-background-trek'] = Object.assign(Object.assign({}, mapConfig.style.sources['tiles-background']), {\n                tiles: [yield this.getTilesDirectoryForTrekById(trek.properties.id)]\n              });\n              mapConfig.style.layers.push({\n                id: 'tiles-background-trek',\n                type: 'raster',\n                source: 'tiles-background-trek',\n                minzoom: environment.trekZoom.minZoom,\n                maxzoom: environment.trekZoom.maxZoom\n              });\n              mapConfig.maxZoom = environment.trekZoom.maxZoom - 1;\n            }\n          }\n        } else {\n          mapConfig = Object.assign(Object.assign({}, cloneDeep(environment.onlineMapConfig)), {\n            zoom: environment.trekZoom.zoom\n          });\n        }\n\n        mapConfig.trekBounds = trek.bbox;\n        mapConfig.center = undefined;\n        return mapConfig;\n      });\n    }\n\n    getTilesDirectoryForTrekById(trekId) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return `${Capacitor.convertFileSrc((yield Filesystem.getUri({\n          path: 'offline',\n          directory: Directory.Data\n        })).uri)}/${trekId}/tiles/{z}/{x}/{y}.png`;\n      });\n    }\n\n    trekIsAvailableOffline(trekId) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return Boolean((yield Storage.get({\n          key: `trek-${trekId}`\n        })).value);\n      });\n    }\n\n  }\n\n  OfflineTreksService.ɵfac = function OfflineTreksService_Factory(t) {\n    return new (t || OfflineTreksService)(i0.ɵɵinject(i1.Platform), i0.ɵɵinject(i2.FilterTreksService), i0.ɵɵinject(i3.OnlineTreksService));\n  };\n\n  OfflineTreksService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: OfflineTreksService,\n    factory: OfflineTreksService.ɵfac,\n    providedIn: 'root'\n  });\n  return OfflineTreksService;\n})();","map":null,"metadata":{},"sourceType":"module"}