{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { EventEmitter } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { filter, distinctUntilChanged } from 'rxjs/operators';\nimport { SelectTrekComponent } from '@app/components/select-trek/select-trek.component';\nimport { InAppDisclosureComponent } from '@app/components/in-app-disclosure/in-app-disclosure.component';\nimport { environment } from '@env/environment';\nimport { throttle } from 'lodash';\nimport mapboxgl from 'mapbox-gl/dist/mapbox-gl.js';\nimport { Capacitor } from '@capacitor/core';\nimport { Directory, Filesystem } from '@capacitor/filesystem';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/services/settings/settings.service\";\nimport * as i2 from \"@ionic/angular\";\nimport * as i3 from \"@app/services/geolocate/geolocate.service\";\nimport * as i4 from \"@ngx-translate/core\";\nimport * as i5 from \"@app/services/offline-treks/offline-treks.service\";\nconst _c0 = [\"mapViz\"];\nexport let MapTreksVizComponent = /*#__PURE__*/(() => {\n  class MapTreksVizComponent {\n    constructor(settings, platform, geolocate, modalController, alertController, translate, offlineTreks) {\n      this.settings = settings;\n      this.platform = platform;\n      this.geolocate = geolocate;\n      this.modalController = modalController;\n      this.alertController = alertController;\n      this.translate = translate;\n      this.offlineTreks = offlineTreks;\n      this.filteredTreks = null;\n      this.navigateToTrek = new EventEmitter();\n      this.flyToUserLocation = throttle(this.flyToUserLocation, 3000);\n    }\n\n    ngOnChanges(changes) {\n      const changesCurrentTreks = changes.filteredTreks;\n\n      if (changesCurrentTreks) {\n        if (changesCurrentTreks.currentValue && !changesCurrentTreks.previousValue) {\n          this.createMap();\n        } else {\n          if (this.map) {\n            const treksSource = this.map.getSource('treks-points');\n\n            if (treksSource && this.filteredTreks) {\n              treksSource.setData({\n                type: 'FeatureCollection',\n                features: this.filteredTreks\n              });\n            }\n          }\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.geolocate.stopOnMapTracking();\n\n      if (this.currentPositionSubscription) {\n        this.currentPositionSubscription.unsubscribe();\n      }\n\n      if (this.currentHeadingSubscription) {\n        this.currentHeadingSubscription.unsubscribe();\n      }\n\n      if (this.loadImagesSubscription) {\n        this.loadImagesSubscription.unsubscribe();\n      }\n    }\n\n    createMap() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.mapConfig && this.mapConfig.style && this.filteredTreks) {\n          if (this.offline && (this.platform.is('ios') || this.platform.is('android'))) {\n            this.mapConfig.style.sources['tiles-background'].tiles[0] = `${Capacitor.convertFileSrc((yield Filesystem.getUri({\n              path: 'offline',\n              directory: Directory.Data\n            })).uri)}/tiles/{z}/{x}/{y}.png`;\n          }\n\n          const coordinates = [];\n          this.filteredTreks.forEach(feature => {\n            if (feature && feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates[0] && feature.geometry.coordinates[1]) {\n              coordinates.push(feature.geometry.coordinates);\n            }\n          });\n          const bounds = coordinates.reduce((bounds, coord) => bounds.extend(coord), new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n          this.map = new mapboxgl.Map(Object.assign(Object.assign({}, this.mapConfig), {\n            container: 'map-treks'\n          }));\n\n          if (bounds && bounds._ne && bounds._sw) {\n            this.map.fitBounds(bounds, environment.map.TreksfitBoundsOptions);\n          }\n\n          this.map.addControl(new mapboxgl.NavigationControl({\n            showCompass: false\n          }), 'top-left');\n          this.map.addControl(new mapboxgl.ScaleControl({\n            unit: 'metric'\n          }));\n          this.map.addControl(new mapboxgl.AttributionControl({\n            compact: false,\n            customAttribution: environment.map.attributionText\n          }));\n\n          if (!environment.map.enableRotation) {\n            this.map.dragRotate.disable();\n            this.map.touchZoomRotate.disableRotation();\n          }\n\n          const loadImages = Observable.create(observer => {\n            const practices = this.dataSettings.find(data => data.id === 'practice');\n\n            if (practices) {\n              this.practices = practices;\n              practices.values.forEach((practice, index) => __awaiter(this, void 0, void 0, function* () {\n                this.map.loadImage(yield this.offlineTreks.getTrekImageSrc({}, {\n                  url: practice.pictogram\n                }), (error, image) => {\n                  if (!error) {\n                    this.map.addImage(practice.id.toString(), image);\n\n                    if (index + 1 === practices.values.length) {\n                      observer.complete();\n                    }\n                  } else {\n                    this.map.loadImage(`${this.commonSrc}${practice.pictogram}`, (error, image) => {\n                      if (!error) {\n                        this.map.addImage(practice.id.toString(), image);\n                      }\n\n                      if (index + 1 === practices.values.length) {\n                        observer.complete();\n                      }\n                    });\n                  }\n                });\n              }));\n            }\n          });\n          this.currentPositionSubscription = this.geolocate.currentPosition$.pipe(filter(currentPosition => currentPosition !== null), distinctUntilChanged()).subscribe(location => __awaiter(this, void 0, void 0, function* () {\n            const coordinates = [location.longitude, location.latitude];\n\n            if (this.markerPosition) {\n              this.markerPosition.setLngLat(coordinates);\n            } else {\n              const el = document.createElement('div');\n              const currentHeading = yield this.geolocate.checkIfCanGetCurrentHeading();\n              el.className = currentHeading ? 'pulse-and-view' : 'pulse';\n              this.markerPosition = new mapboxgl.Marker({\n                element: el\n              }).setLngLat(coordinates);\n\n              if (this.markerPosition) {\n                this.markerPosition.addTo(this.map);\n              }\n            }\n          }));\n          this.currentHeadingSubscription = this.geolocate.currentHeading$.subscribe(heading => {\n            if (this.markerPosition && heading) {\n              this.markerPosition.setRotation(heading);\n            }\n          });\n          this.loadImagesSubscription = loadImages.subscribe({\n            complete: () => __awaiter(this, void 0, void 0, function* () {\n              this.addSourcesLayersEvents();\n              const shouldShowInAppDisclosure = yield this.geolocate.shouldShowInAppDisclosure();\n\n              if (shouldShowInAppDisclosure) {\n                yield this.presentInAppDisclosure();\n              }\n\n              this.geolocate.startOnMapTracking();\n            })\n          });\n        }\n      });\n    }\n\n    addSourcesLayersEvents() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.map.addSource('treks-points', {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection',\n            features: this.filteredTreks\n          },\n          maxzoom: this.mapConfig.maxZoom ? this.mapConfig.maxZoom + 1 : 18,\n          cluster: true,\n          clusterRadius: 50\n        });\n        this.map.addSource('zone', {\n          type: 'geojson',\n          data: yield this.settings.getZoneFromStorage()\n        });\n        this.map.addLayer(Object.assign({\n          id: 'zone',\n          source: 'zone'\n        }, environment.map.zoneLayerProperties));\n        this.map.addLayer(Object.assign({\n          id: 'zone-outline',\n          source: 'zone'\n        }, environment.map.zoneOutlineLayerProperties));\n        this.map.addLayer({\n          id: 'clusters-circle',\n          type: 'circle',\n          source: 'treks-points',\n          filter: ['has', 'point_count'],\n          paint: environment.map.clusterPaint\n        });\n        this.map.addLayer({\n          id: 'cluster-text-count',\n          type: 'symbol',\n          source: 'treks-points',\n          filter: ['has', 'point_count'],\n          paint: environment.map.clusterTextPaint,\n          layout: {\n            'text-field': '{point_count_abbreviated}',\n            'text-font': ['Roboto Regular'],\n            'text-size': 16,\n            'text-offset': [0, 0.1]\n          }\n        });\n        const circleColorExpression = [];\n        circleColorExpression.push('match');\n        circleColorExpression.push(['get', 'practice']);\n        this.practices.values.forEach(practice => {\n          circleColorExpression.push(practice.id);\n          circleColorExpression.push(practice.color);\n        });\n        circleColorExpression.push(environment.map.clusterPaint['circle-color']);\n        this.map.addLayer({\n          id: 'trek-point',\n          type: 'circle',\n          source: 'treks-points',\n          filter: ['!', ['has', 'point_count']],\n          paint: Object.assign(Object.assign({}, environment.map.clusterPaint), {\n            'circle-color': circleColorExpression,\n            'circle-radius': 16\n          })\n        });\n        this.map.addLayer({\n          id: 'trek-point-icon',\n          type: 'symbol',\n          source: 'treks-points',\n          filter: ['!', ['has', 'point_count']],\n          layout: {\n            'icon-image': ['get', 'practice'],\n            'icon-size': environment.map.globalMapIconSize\n          }\n        });\n        this.map.on('click', 'clusters-circle', e => {\n          const features = this.map.queryRenderedFeatures(e.point, {\n            layers: ['clusters-circle']\n          });\n          const featureProperties = features[0].properties;\n\n          if (!!featureProperties) {\n            const clusterId = featureProperties.cluster_id;\n\n            if (this.map.getZoom() === this.mapConfig.maxZoom) {\n              this.map.getSource('treks-points').getClusterLeaves(featureProperties.cluster_id, Infinity, 0, (err, featuresInCluster) => {\n                if (err) {\n                  throw err;\n                }\n\n                this.presentConfirmFeatures(featuresInCluster);\n              });\n            } else {\n              this.map.getSource('treks-points').getClusterExpansionZoom(clusterId, (err, zoom) => {\n                if (err) {\n                  return;\n                }\n\n                const coordinates = features[0].geometry.coordinates;\n                this.map.easeTo({\n                  center: [coordinates[0], coordinates[1]],\n                  zoom: zoom\n                });\n              });\n            }\n          }\n        });\n        this.map.on('click', 'trek-point', e => {\n          const feature = this.map.queryRenderedFeatures(e.point, {\n            layers: ['trek-point']\n          })[0];\n\n          if (!!feature.properties) {\n            this.navigateToTrek.emit(feature.properties.id);\n          }\n        });\n        this.mapViz.nativeElement.mapInstance = this.map;\n      });\n    }\n\n    presentConfirmFeatures(features) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const radioTreks = [];\n        features.forEach(feature => {\n          const hydratedTrek = this.settings.getHydratedTrek(feature, this.commonSrc);\n          const trek = {\n            id: hydratedTrek.properties.id,\n            name: hydratedTrek.properties.name,\n            imgPractice: {\n              src: hydratedTrek.properties.practice.pictogram,\n              color: hydratedTrek.properties.practice.color\n            }\n          };\n          radioTreks.push(trek);\n        });\n        const modal = yield this.modalController.create({\n          component: SelectTrekComponent,\n          componentProps: {\n            radioTreks\n          },\n          cssClass: 'full-size'\n        });\n        yield modal.present();\n        const {\n          data\n        } = yield modal.onDidDismiss();\n\n        if (data && data.selectedTrekId) {\n          this.navigateToTrek.emit(data.selectedTrekId);\n        }\n      });\n    }\n\n    flyToUserLocation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const userLocation = yield this.geolocate.getCurrentPosition();\n\n        if (userLocation) {\n          const coordinates = [userLocation.longitude, userLocation.latitude];\n\n          if (this.markerPosition) {\n            this.markerPosition.setLngLat(coordinates);\n          } else {\n            const el = document.createElement('div');\n            const currentHeading = yield this.geolocate.checkIfCanGetCurrentHeading();\n            el.className = currentHeading ? 'pulse-and-view' : 'pulse';\n            this.markerPosition = new mapboxgl.Marker({\n              element: el\n            }).setLngLat(coordinates);\n\n            if (this.markerPosition) {\n              this.markerPosition.addTo(this.map);\n            }\n          }\n\n          this.map.flyTo({\n            center: coordinates,\n            animate: false,\n            zoom: environment.trekZoom.zoom\n          });\n        } else {\n          const errorTranslation = yield this.translate.get('geolocate.error').toPromise();\n          const alertLocation = yield this.alertController.create({\n            header: errorTranslation['header'],\n            subHeader: errorTranslation['subHeader'],\n            message: errorTranslation['message'],\n            buttons: [errorTranslation['confirmButton']]\n          });\n          yield alertLocation.present();\n        }\n      });\n    }\n\n    presentInAppDisclosure() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const modal = yield this.modalController.create({\n          component: InAppDisclosureComponent,\n          componentProps: {},\n          cssClass: 'full-size'\n        });\n        yield modal.present();\n        yield modal.onDidDismiss();\n      });\n    }\n\n  }\n\n  MapTreksVizComponent.ɵfac = function MapTreksVizComponent_Factory(t) {\n    return new (t || MapTreksVizComponent)(i0.ɵɵdirectiveInject(i1.SettingsService), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(i3.GeolocateService), i0.ɵɵdirectiveInject(i2.ModalController), i0.ɵɵdirectiveInject(i2.AlertController), i0.ɵɵdirectiveInject(i4.TranslateService), i0.ɵɵdirectiveInject(i5.OfflineTreksService));\n  };\n\n  MapTreksVizComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MapTreksVizComponent,\n    selectors: [[\"app-map-treks-viz\"]],\n    viewQuery: function MapTreksVizComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mapViz = _t.first);\n      }\n    },\n    inputs: {\n      filteredTreks: \"filteredTreks\",\n      mapConfig: \"mapConfig\",\n      dataSettings: \"dataSettings\",\n      commonSrc: \"commonSrc\",\n      offline: \"offline\"\n    },\n    outputs: {\n      navigateToTrek: \"navigateToTrek\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 0,\n    consts: [[\"id\", \"map-treks\", 1, \"map-viz\"], [\"mapViz\", \"\"], [1, \"options-button-container\"], [\"shape\", \"round\", \"size\", \"small\", \"color\", \"light\", 3, \"click\"], [\"color\", \"dark\", \"name\", \"locate\"]],\n    template: function MapTreksVizComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n        i0.ɵɵelementStart(2, \"div\", 2)(3, \"ion-button\", 3);\n        i0.ɵɵlistener(\"click\", function MapTreksVizComponent_Template_ion_button_click_3_listener() {\n          return ctx.flyToUserLocation();\n        });\n        i0.ɵɵelement(4, \"ion-icon\", 4);\n        i0.ɵɵelementEnd()();\n      }\n    },\n    directives: [i2.IonButton, i2.IonIcon],\n    styles: [\".options-button-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:absolute;right:24px;top:24px;z-index:5}\"]\n  });\n  return MapTreksVizComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}