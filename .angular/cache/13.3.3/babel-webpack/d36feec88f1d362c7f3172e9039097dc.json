{"ast":null,"code":"import { combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { point } from '@turf/helpers';\nimport distance from '@turf/distance';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/services/settings/settings.service\";\nexport let FilterTreksService = /*#__PURE__*/(() => {\n  class FilterTreksService {\n    constructor(settings) {\n      this.settings = settings;\n      this.activeFiltersNumber$ = settings.filters$.pipe(map(filters => FilterTreksService.getNumberOfActiveFilters(filters)));\n    }\n\n    static filter(treks, filters) {\n      if (!treks) {\n        return [];\n      }\n\n      let filteredFeatures = treks.features;\n\n      if (filters) {\n        filters.forEach(filter => {\n          filteredFeatures = filteredFeatures.filter(feature => {\n            if (!FilterTreksService.isFilterActive(filter)) {\n              return true;\n            }\n\n            if (filter.type === 'contains') {\n              return FilterTreksService.containsFilter(filter, feature);\n            } else if (filter.type === 'interval') {\n              return FilterTreksService.intervalFilter(filter, feature);\n            }\n\n            return false;\n          });\n        });\n      }\n\n      return filteredFeatures;\n    }\n\n    static sort(filteredTreks, order, userLocation) {\n      return filteredTreks.sort((a, b) => {\n        if (order === 'location' && userLocation && userLocation !== null) {\n          if (!a.geometry || !b.geometry) {\n            return !a.geometry ? 1 : -1;\n          }\n\n          const distanceFromTrekA = distance(point(a.geometry.coordinates), point(userLocation));\n          const distanceFromTrekB = distance(point(b.geometry.coordinates), point(userLocation));\n\n          if (distanceFromTrekA < distanceFromTrekB) {\n            return -1;\n          }\n\n          if (distanceFromTrekA > distanceFromTrekB) {\n            return 1;\n          }\n\n          return 0;\n        }\n\n        if (order === 'alphabetical') {\n          if (a.properties.name < b.properties.name) {\n            return -1;\n          }\n\n          if (a.properties.name > b.properties.name) {\n            return 1;\n          }\n\n          return 0;\n        }\n\n        if (order === 'random') {\n          return 0.5 - Math.random();\n        }\n\n        return 0;\n      });\n    }\n\n    static isFilterActive(filter) {\n      return filter.values.filter(value => value.checked).length > 0;\n    }\n\n    static getNumberOfActiveFilters(filters) {\n      let numberOfActiveFilters = 0;\n\n      if (!!filters) {\n        filters.forEach(filter => {\n          numberOfActiveFilters += FilterTreksService.getCheckedIdForFilter(filter).length;\n        });\n      }\n\n      return numberOfActiveFilters;\n    }\n\n    static intervalFilter(filter, feature) {\n      let isInInterval = false;\n      FilterTreksService.getCheckedInterval(filter).forEach(([min, max]) => {\n        const criterionValue = feature.properties[filter.id];\n\n        if (criterionValue >= min && criterionValue <= max) {\n          isInInterval = true;\n          return;\n        }\n      });\n      return isInInterval;\n    }\n\n    static containsFilter(filter, feature) {\n      if (Array.isArray(feature.properties[filter.id])) {\n        return FilterTreksService.getCheckedIdForFilter(filter).find(filterValue => feature.properties[filter.id].indexOf(filterValue) !== -1) !== undefined;\n      } else {\n        return FilterTreksService.getCheckedIdForFilter(filter).indexOf(feature.properties[filter.id]) !== -1;\n      }\n    }\n\n    static getCheckedIdForFilter(filter) {\n      return filter.values.filter(value => value.checked).map(checkedValue => checkedValue.id);\n    }\n\n    static getCheckedInterval(filter) {\n      return filter.values.filter(value => !!value.interval && value.checked).map(checkedValue => checkedValue.interval);\n    }\n\n    getFilteredTreks(treks$) {\n      return combineLatest([treks$, this.settings.filters$, this.settings.order$]).pipe(map(([treks, filters, order]) => {\n        if (treks && filters && order) {\n          return FilterTreksService.sort(FilterTreksService.filter(treks, filters), order.type, order.value);\n        } else {\n          return [];\n        }\n      }));\n    }\n\n  }\n\n  FilterTreksService.ɵfac = function FilterTreksService_Factory(t) {\n    return new (t || FilterTreksService)(i0.ɵɵinject(i1.SettingsService));\n  };\n\n  FilterTreksService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FilterTreksService,\n    factory: FilterTreksService.ɵfac,\n    providedIn: 'root'\n  });\n  return FilterTreksService;\n})();","map":null,"metadata":{},"sourceType":"module"}