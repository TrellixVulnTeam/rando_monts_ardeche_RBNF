{"ast":null,"code":"import _asyncToGenerator from \"/Users/macintosh/Dev/Geotrek/rando-monts-ardeche/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { readBlobAsBase64 } from './utils';\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\n\nconst normalizeHttpHeaders = (headers = {}) => {\n  const originalKeys = Object.keys(headers);\n  const loweredKeys = Object.keys(headers).map(k => k.toLocaleLowerCase());\n  const normalized = loweredKeys.reduce((acc, key, index) => {\n    acc[key] = headers[originalKeys[index]];\n    return acc;\n  }, {});\n  return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\n\n\nconst buildUrlParams = (params, shouldEncode = true) => {\n  if (!params) return null;\n  const output = Object.entries(params).reduce((accumulator, entry) => {\n    const [key, value] = entry;\n    let encodedValue;\n    let item;\n\n    if (Array.isArray(value)) {\n      item = '';\n      value.forEach(str => {\n        encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n        item += `${key}=${encodedValue}&`;\n      }); // last character will always be \"&\" so slice it off\n\n      item.slice(0, -1);\n    } else {\n      encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n      item = `${key}=${encodedValue}`;\n    }\n\n    return `${accumulator}&${item}`;\n  }, ''); // Remove initial \"&\" from the reduce\n\n  return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\n\n\nexport const buildRequestInit = (options, extra = {}) => {\n  const output = Object.assign({\n    method: options.method || 'GET',\n    headers: options.headers\n  }, extra); // Get the content-type\n\n  const headers = normalizeHttpHeaders(options.headers);\n  const type = headers['content-type'] || ''; // If body is already a string, then pass it through as-is.\n\n  if (typeof options.data === 'string') {\n    output.body = options.data;\n  } // Build request initializers based off of content-type\n  else if (type.includes('application/x-www-form-urlencoded')) {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(options.data || {})) {\n      params.set(key, value);\n    }\n\n    output.body = params.toString();\n  } else if (type.includes('multipart/form-data')) {\n    const form = new FormData();\n\n    if (options.data instanceof FormData) {\n      options.data.forEach((value, key) => {\n        form.append(key, value);\n      });\n    } else {\n      for (let key of Object.keys(options.data)) {\n        form.append(key, options.data[key]);\n      }\n    }\n\n    output.body = form;\n    const headers = new Headers(output.headers);\n    headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n\n    output.headers = headers;\n  } else if (type.includes('application/json') || typeof options.data === 'object') {\n    output.body = JSON.stringify(options.data);\n  }\n\n  return output;\n};\n/**\n * Perform an Http request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const request = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (options) {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n    const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n    const response = yield fetch(url, requestInit);\n    const contentType = response.headers.get('content-type') || ''; // Default to 'text' responseType so no parsing happens\n\n    let {\n      responseType = 'text'\n    } = response.ok ? options : {}; // If the response content-type is json, force the response to be json\n\n    if (contentType.includes('application/json')) {\n      responseType = 'json';\n    }\n\n    let data;\n\n    switch (responseType) {\n      case 'arraybuffer':\n      case 'blob':\n        const blob = yield response.blob();\n        data = yield readBlobAsBase64(blob);\n        break;\n\n      case 'json':\n        data = yield response.json();\n        break;\n\n      case 'document':\n      case 'text':\n      default:\n        data = yield response.text();\n    } // Convert fetch headers to Capacitor HttpHeaders\n\n\n    const headers = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return {\n      data,\n      headers,\n      status: response.status,\n      url: response.url\n    };\n  });\n\n  return function request(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http GET request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const get = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'GET'\n    }));\n  });\n\n  return function get(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http POST request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const post = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'POST'\n    }));\n  });\n\n  return function post(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http PUT request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const put = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'PUT'\n    }));\n  });\n\n  return function put(_x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http PATCH request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const patch = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'PATCH'\n    }));\n  });\n\n  return function patch(_x5) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http DELETE request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const del = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'DELETE'\n    }));\n  });\n\n  return function del(_x6) {\n    return _ref6.apply(this, arguments);\n  };\n}(); //# sourceMappingURL=request.js.map","map":null,"metadata":{},"sourceType":"module"}