{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { EventEmitter } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { filter, distinctUntilChanged } from 'rxjs/operators';\nimport { SelectPoiComponent } from '@app/components/select-poi/select-poi.component';\nimport { InAppDisclosureComponent } from '@app/components/in-app-disclosure/in-app-disclosure.component';\nimport { environment } from '@env/environment';\nimport { Map } from 'mapbox-gl';\nimport { LayersVisibilityComponent } from '@app/components/layers-visibility/layers-visibility.component';\nimport { throttle } from 'lodash';\nimport mapboxgl from 'mapbox-gl/dist/mapbox-gl.js';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/services/settings/settings.service\";\nimport * as i2 from \"@app/services/geolocate/geolocate.service\";\nimport * as i3 from \"@ionic/angular\";\nimport * as i4 from \"@ngx-translate/core\";\nimport * as i5 from \"@app/services/offline-treks/offline-treks.service\";\nconst _c0 = [\"mapViz\"];\nexport let MapTrekVizComponent = /*#__PURE__*/(() => {\n  class MapTrekVizComponent {\n    constructor(settings, geolocate, popoverController, translate, alertController, modalController, offlineTreks) {\n      this.settings = settings;\n      this.geolocate = geolocate;\n      this.popoverController = popoverController;\n      this.translate = translate;\n      this.alertController = alertController;\n      this.modalController = modalController;\n      this.offlineTreks = offlineTreks;\n      this.navigateModeIsActive = false;\n      this.currentTrek = null;\n      this.presentPoiDetails = new EventEmitter();\n      this.presentInformationDeskDetails = new EventEmitter();\n      this.navigateToChildren = new EventEmitter();\n      this.flyToUserLocation = throttle(this.flyToUserLocation, 3000);\n    }\n\n    ngOnChanges(changes) {\n      const changesCurrentTrek = changes.currentTrek;\n      const changesCurrentPois = changes.currentPois;\n      const touristicCategoriesWithFeatures = changes.touristicCategoriesWithFeatures;\n\n      if (!!this.currentTrek && !!this.currentPois && !!this.touristicCategoriesWithFeatures && (changesCurrentTrek && !changesCurrentTrek.previousValue || changesCurrentPois && !changesCurrentPois.previousValue || touristicCategoriesWithFeatures && !touristicCategoriesWithFeatures.previousValue)) {\n        this.createMap();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.navigate$) {\n        this.navigate$.unsubscribe();\n      }\n\n      this.geolocate.stopOnMapTracking();\n\n      if (this.currentPositionSubscription) {\n        this.currentPositionSubscription.unsubscribe();\n      }\n\n      if (this.currentHeadingSubscription) {\n        this.currentHeadingSubscription.unsubscribe();\n      }\n\n      if (this.loadImagesSubscription) {\n        this.loadImagesSubscription.unsubscribe();\n      }\n    }\n\n    createMap() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.mapConfig && this.mapConfig.style) {\n          this.map = new Map(Object.assign(Object.assign({}, this.mapConfig), {\n            container: 'map-trek'\n          }));\n          this.map.fitBounds(this.mapConfig.trekBounds, environment.map.TrekfitBoundsOptions);\n          this.map.addControl(new mapboxgl.NavigationControl({\n            showCompass: false\n          }), 'top-left');\n          this.map.addControl(new mapboxgl.ScaleControl({\n            unit: 'metric'\n          }));\n          this.map.addControl(new mapboxgl.AttributionControl({\n            compact: false,\n            customAttribution: environment.map.attributionText\n          }));\n\n          if (!environment.map.enableRotation) {\n            this.map.dragRotate.disable();\n            this.map.touchZoomRotate.disableRotation();\n          }\n\n          this.map.on('click', 'pois-icon', e => {\n            if (!!e.features && e.features.length > 0) {\n              const poi = Object.assign({}, e.features[0]);\n\n              if (poi.properties && poi.properties.pictures) {\n                poi.properties.pictures = JSON.parse(poi.properties.pictures);\n              }\n\n              this.presentPoiDetails.emit(poi);\n            }\n          });\n          this.map.on('click', 'information-desk-icon', e => {\n            const childrenTreks = this.map.queryRenderedFeatures(e.point, {\n              layers: [`children-treks-circle`]\n            });\n\n            if (!!e.features && e.features.length > 0 && (!childrenTreks || !(childrenTreks.length > 0))) {\n              if (e.features[0] && e.features[0].properties && e.features[0].properties.id && this.currentTrek) {\n                const informationDesk = this.currentTrek.properties.information_desks.find(informationDeskProperty => informationDeskProperty.id === e.features[0].properties.id);\n                this.presentInformationDeskDetails.emit(informationDesk);\n              }\n            }\n          });\n          this.map.on('click', 'touristics-content-icon', e => {\n            if (!!e.features && e.features.length > 0) {\n              const touristicContent = Object.assign({}, e.features[0]);\n\n              if (touristicContent.properties && touristicContent.properties.pictures) {\n                touristicContent.properties.pictures = JSON.parse(touristicContent.properties.pictures);\n              }\n\n              this.presentPoiDetails.emit(touristicContent);\n            }\n          });\n          this.map.on('click', 'children-treks-circle', e => {\n            if (!!e.features && e.features.length > 0) {\n              const childrenTrek = Object.assign({}, e.features[0]);\n\n              if (childrenTrek.properties && childrenTrek.properties.id) {\n                this.navigateToChildren.emit(childrenTrek.properties.id);\n              }\n            }\n          });\n          this.handleClustersInteraction();\n          const loadImages = Observable.create(observer => {\n            const imagesToLoad = [];\n            this.poisType = this.dataSettings.find(data => data.id === 'poi_types');\n\n            if (this.poisType) {\n              this.poisType.values.forEach(poiType => {\n                if (poiType.pictogram) {\n                  imagesToLoad.push({\n                    id: `pois${poiType.id}`,\n                    pictogram: poiType.pictogram\n                  });\n                }\n              });\n            }\n\n            const typeInformationDesks = this.dataSettings.find(data => data.id === 'information_desk_types');\n\n            if (typeInformationDesks) {\n              typeInformationDesks.values.forEach(typeInformationDesk => {\n                if (typeInformationDesk.pictogram) {\n                  imagesToLoad.push({\n                    id: `informationDesk${typeInformationDesk.id}`,\n                    pictogram: typeInformationDesk.pictogram\n                  });\n                }\n              });\n            }\n\n            const touristicsContent = this.dataSettings.find(data => data.id === 'touristiccontent_categories');\n\n            if (touristicsContent) {\n              touristicsContent.values.forEach(touristicContent => {\n                if (touristicContent.pictogram) {\n                  imagesToLoad.push({\n                    id: `touristicContent${touristicContent.id}`,\n                    pictogram: touristicContent.pictogram\n                  });\n                }\n              });\n            }\n\n            imagesToLoad.push({\n              id: 'arrival',\n              pictogram: './assets/map/icons/departure.png',\n              fromAssets: true\n            });\n            imagesToLoad.push({\n              id: 'departure',\n              pictogram: './assets/map/icons/arrival.png',\n              fromAssets: true\n            });\n            imagesToLoad.push({\n              id: 'departureArrival',\n              pictogram: './assets/map/icons/departureArrival.png',\n              fromAssets: true\n            });\n            imagesToLoad.push({\n              id: 'parking',\n              pictogram: './assets/map/icons/parking.png',\n              fromAssets: true\n            });\n            imagesToLoad.push({\n              id: 'arrow',\n              pictogram: './assets/map/icons/arrow.png',\n              fromAssets: true\n            });\n            imagesToLoad.forEach((imageToLoad, index) => __awaiter(this, void 0, void 0, function* () {\n              this.map.loadImage(imageToLoad.fromAssets ? imageToLoad.pictogram : yield this.offlineTreks.getTrekImageSrc({}, {\n                url: imageToLoad.pictogram\n              }), (error, image) => {\n                if (!error) {\n                  this.map.addImage(imageToLoad.id.toString(), image);\n\n                  if (index + 1 === imagesToLoad.length) {\n                    observer.complete();\n                  }\n                } else {\n                  this.map.loadImage(`${this.commonSrc}${imageToLoad.pictogram}`, (error, image) => {\n                    if (!error) {\n                      this.map.addImage(imageToLoad.id.toString(), image);\n                    }\n\n                    if (index + 1 === imagesToLoad.length) {\n                      observer.complete();\n                    }\n                  });\n                }\n              });\n            }));\n          });\n          this.currentPositionSubscription = this.geolocate.currentPosition$.pipe(filter(currentPosition => currentPosition !== null), distinctUntilChanged()).subscribe(location => __awaiter(this, void 0, void 0, function* () {\n            const coordinates = [location.longitude, location.latitude];\n\n            if (this.markerPosition) {\n              this.markerPosition.setLngLat(coordinates);\n            } else {\n              const el = document.createElement('div');\n              const currentHeading = yield this.geolocate.checkIfCanGetCurrentHeading();\n              el.className = currentHeading ? 'pulse-and-view' : 'pulse';\n              this.markerPosition = new mapboxgl.Marker({\n                element: el\n              }).setLngLat(coordinates);\n\n              if (this.markerPosition) {\n                this.markerPosition.addTo(this.map);\n              }\n            }\n          }));\n          this.currentHeadingSubscription = this.geolocate.currentHeading$.subscribe(heading => {\n            if (this.markerPosition && heading) {\n              this.markerPosition.setRotation(heading);\n            }\n          });\n          this.loadImagesSubscription = loadImages.subscribe({\n            complete: () => __awaiter(this, void 0, void 0, function* () {\n              this.mapViz.nativeElement.mapInstance = this.map;\n              yield this.initializeSources();\n              this.initializeLayers();\n              this.updateSources();\n              const shouldShowInAppDisclosure = yield this.geolocate.shouldShowInAppDisclosure();\n\n              if (shouldShowInAppDisclosure) {\n                yield this.presentInAppDisclosure();\n              }\n\n              this.geolocate.startOnMapTracking();\n            })\n          });\n        }\n      });\n    }\n\n    initializeSources() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const data = {\n          type: 'FeatureCollection',\n          features: []\n        };\n        this.map.addSource('zone', {\n          type: 'geojson',\n          data: yield this.settings.getZoneFromStorage()\n        });\n        this.map.addSource('trek', {\n          type: 'geojson',\n          data\n        });\n        this.map.addSource('departure-arrival', {\n          type: 'geojson',\n          data\n        });\n        this.map.addSource('pois', {\n          type: 'geojson',\n          data,\n          maxzoom: this.mapConfig.maxZoom ? this.mapConfig.maxZoom + 1 : 18,\n          cluster: true,\n          clusterRadius: 50\n        });\n        this.map.addSource('touristics-content', {\n          type: 'geojson',\n          data,\n          maxzoom: this.mapConfig.maxZoom ? this.mapConfig.maxZoom + 1 : 18,\n          cluster: true,\n          clusterRadius: 50\n        });\n        this.map.addSource('information-desk', {\n          type: 'geojson',\n          data\n        });\n        this.map.addSource('parking', {\n          type: 'geojson',\n          data\n        });\n        this.map.addSource('points-reference', {\n          type: 'geojson',\n          data\n        });\n        this.map.addSource('children-treks', {\n          type: 'geojson',\n          data\n        });\n      });\n    }\n\n    initializeLayers() {\n      const visibility = this.currentTrek && this.currentTrek.properties.children && this.currentTrek.properties.children.features.length > 0 ? 'none' : 'visible';\n      this.map.addLayer(Object.assign({\n        id: 'zone',\n        source: 'zone'\n      }, environment.map.zoneLayerProperties));\n      this.map.addLayer(Object.assign({\n        id: 'zone-outline',\n        source: 'zone'\n      }, environment.map.zoneOutlineLayerProperties));\n      this.map.addLayer(Object.assign({\n        id: 'trek-line',\n        type: 'line',\n        source: 'trek'\n      }, environment.map.trekLineLayerProperties));\n      this.map.addLayer({\n        id: 'arrow-layer',\n        type: 'symbol',\n        source: 'trek',\n        layout: Object.assign({\n          'icon-image': 'arrow'\n        }, environment.map.trekArrowLayerProperties.layout)\n      });\n      this.map.addLayer(Object.assign({\n        id: 'points-reference-circle',\n        type: 'circle',\n        source: 'points-reference'\n      }, environment.map.pointReferenceLayersProperties.circle));\n      this.map.addLayer(Object.assign({\n        id: 'points-reference-text',\n        type: 'symbol',\n        source: 'points-reference'\n      }, environment.map.pointReferenceLayersProperties.text));\n      this.map.addLayer({\n        id: 'pois-icon',\n        type: 'symbol',\n        source: 'pois',\n        filter: ['!', ['has', 'point_count']],\n        layout: {\n          'icon-image': ['concat', 'pois', ['get', 'type']],\n          'icon-size': environment.map.poisLayersProperties.iconSize,\n          'icon-allow-overlap': true,\n          visibility: visibility === 'visible' ? environment.map.poisLayersProperties.visibility : visibility\n        }\n      });\n      this.map.addLayer({\n        id: 'clusters-circle-pois',\n        type: 'circle',\n        source: 'pois',\n        filter: ['has', 'point_count'],\n        paint: environment.map.clusterPaint,\n        layout: {\n          visibility: visibility === 'visible' ? environment.map.poisLayersProperties.visibility : visibility\n        }\n      });\n      this.map.addLayer({\n        id: 'cluster-text-count-pois',\n        type: 'symbol',\n        source: 'pois',\n        filter: ['has', 'point_count'],\n        paint: environment.map.clusterTextPaint,\n        layout: {\n          'text-field': '{point_count_abbreviated}',\n          'text-font': ['Roboto Regular'],\n          'text-size': 18,\n          'text-offset': [0, 0.1],\n          'text-ignore-placement': true,\n          'text-allow-overlap': true,\n          visibility: visibility === 'visible' ? environment.map.poisLayersProperties.visibility : visibility\n        }\n      });\n      this.touristicsContentCategory = this.dataSettings.find(data => data.id === 'touristiccontent_categories');\n      const circleColorExpression = [];\n\n      if (this.touristicsContentCategory) {\n        circleColorExpression.push('match');\n        circleColorExpression.push(['get', 'category']);\n        this.touristicsContentCategory.values.forEach(category => {\n          circleColorExpression.push(category.id);\n          circleColorExpression.push(category.color);\n        });\n        circleColorExpression.push(environment.map.clusterPaint['circle-color']);\n      }\n\n      this.map.addLayer({\n        id: 'touristics-content-circle',\n        type: 'circle',\n        source: 'touristics-content',\n        filter: ['!', ['has', 'point_count']],\n        paint: Object.assign(Object.assign({}, environment.map.touristicContentLayersProperties.circle.paint), {\n          'circle-color': this.touristicsContentCategory ? circleColorExpression : '#000000'\n        }),\n        layout: {\n          visibility: visibility === 'visible' ? environment.map.touristicContentLayersProperties.visibility : visibility\n        }\n      });\n      this.map.addLayer({\n        id: 'touristics-content-icon',\n        type: 'symbol',\n        source: 'touristics-content',\n        filter: ['!', ['has', 'point_count']],\n        layout: Object.assign({\n          visibility: visibility === 'visible' ? environment.map.touristicContentLayersProperties.visibility : visibility\n        }, environment.map.touristicContentLayersProperties.icon.layout)\n      });\n      this.map.addLayer({\n        id: 'clusters-circle-touristics-content',\n        type: 'circle',\n        source: 'touristics-content',\n        filter: ['has', 'point_count'],\n        paint: environment.map.clusterPaint,\n        layout: {\n          visibility: visibility === 'visible' ? environment.map.touristicContentLayersProperties.visibility : visibility\n        }\n      });\n      this.map.addLayer({\n        id: 'cluster-text-count-touristics-content',\n        type: 'symbol',\n        source: 'touristics-content',\n        filter: ['has', 'point_count'],\n        paint: environment.map.clusterTextPaint,\n        layout: {\n          'text-field': '{point_count_abbreviated}',\n          'text-font': ['Roboto Regular'],\n          'text-size': 18,\n          'text-offset': [0, 0.1],\n          'text-allow-overlap': true,\n          'text-ignore-placement': true,\n          visibility: visibility === 'visible' ? environment.map.touristicContentLayersProperties.visibility : visibility\n        }\n      });\n      this.map.addLayer({\n        id: 'information-desk-icon',\n        type: 'symbol',\n        source: 'information-desk',\n        layout: {\n          'icon-image': ['concat', 'informationDesk', ['get', 'id', ['object', ['get', 'type']]]],\n          'icon-size': environment.map.informationIconSize,\n          'icon-allow-overlap': true\n        }\n      });\n      this.map.addLayer({\n        id: 'parking-icon',\n        type: 'symbol',\n        source: 'parking',\n        layout: {\n          'icon-image': 'parking',\n          'icon-size': environment.map.parkingIconSize,\n          'icon-allow-overlap': true\n        }\n      });\n      this.map.addLayer({\n        id: 'departure-arrival-icon',\n        type: 'symbol',\n        source: 'departure-arrival',\n        layout: {\n          'icon-image': ['case', ['==', ['get', 'type'], 'departure'], 'departure', ['==', ['get', 'type'], 'arrival'], 'arrival', 'departureArrival'],\n          'icon-size': environment.map.departureArrivalIconSize\n        }\n      });\n      this.map.addLayer({\n        id: 'children-treks-circle',\n        type: 'circle',\n        source: 'children-treks',\n        paint: environment.map.stagePaint\n      });\n      this.map.addLayer({\n        id: 'children-treks-index',\n        type: 'symbol',\n        source: 'children-treks',\n        paint: {\n          'text-color': '#000000'\n        },\n        layout: {\n          'text-field': '{index}',\n          'text-font': ['Roboto Regular'],\n          'text-size': 18,\n          'text-offset': [0, 0.1],\n          'text-allow-overlap': true,\n          'text-ignore-placement': true\n        }\n      });\n    }\n\n    updateSources() {\n      if (!!this.map && !!this.currentTrek) {\n        const trekSource = this.map.getSource('trek');\n\n        if (trekSource) {\n          trekSource.setData(this.currentTrek);\n        }\n\n        const departureArrivalSource = this.map.getSource('departure-arrival');\n\n        if (departureArrivalSource && (!this.currentTrek.properties.children || !this.currentTrek.properties.children.features || !(this.currentTrek.properties.children.features.length > 0))) {\n          const departure = this.currentTrek.geometry.coordinates[0];\n          const arrival = this.currentTrek.geometry.coordinates.slice(-1)[0];\n          const departureArrivalData = {\n            type: 'FeatureCollection',\n            features: []\n          };\n\n          if (departure[0] === arrival[0] && departure[1] === arrival[1]) {\n            departureArrivalData.features.push({\n              type: 'Feature',\n              geometry: {\n                type: 'Point',\n                coordinates: departure\n              },\n              properties: {\n                type: 'departure-arrival'\n              }\n            });\n          } else {\n            departureArrivalData.features.push({\n              type: 'Feature',\n              geometry: {\n                type: 'Point',\n                coordinates: departure\n              },\n              properties: {\n                type: 'departure'\n              }\n            });\n            departureArrivalData.features.push({\n              type: 'Feature',\n              geometry: {\n                type: 'Point',\n                coordinates: arrival\n              },\n              properties: {\n                type: 'arrival'\n              }\n            });\n          }\n\n          departureArrivalSource.setData(departureArrivalData);\n        }\n\n        const poisSource = this.map.getSource('pois');\n\n        if (poisSource) {\n          poisSource.setData(this.currentPois);\n        }\n\n        const touristicsContent = this.map.getSource('touristics-content');\n\n        if (touristicsContent) {\n          let touristicsContentFeatures = [];\n          this.touristicCategoriesWithFeatures.forEach(touristicCategoryWithFeatures => {\n            touristicsContentFeatures = touristicsContentFeatures.concat(touristicCategoryWithFeatures.features);\n          });\n          const touristics_content = {\n            type: 'FeatureCollection',\n            features: touristicsContentFeatures\n          };\n          touristicsContent.setData(touristics_content);\n        }\n\n        const parkingSource = this.map.getSource('parking');\n\n        if (parkingSource && this.currentTrek.properties.parking_location) {\n          const parking = {\n            type: 'FeatureCollection',\n            features: []\n          };\n          parking.features.push({\n            type: 'Feature',\n            geometry: {\n              type: 'Point',\n              coordinates: this.currentTrek.properties.parking_location\n            },\n            properties: {}\n          });\n          parkingSource.setData(parking);\n        }\n\n        const informationDeskSource = this.map.getSource('information-desk');\n\n        if (informationDeskSource && this.currentTrek.properties.information_desks && this.currentTrek.properties.information_desks.length > 0) {\n          const informationDesks = {\n            type: 'FeatureCollection',\n            features: []\n          };\n          this.currentTrek.properties.information_desks.forEach(information_desk_property => {\n            if (information_desk_property.longitude && information_desk_property.latitude) {\n              informationDesks.features.push({\n                type: 'Feature',\n                geometry: {\n                  type: 'Point',\n                  coordinates: [information_desk_property.longitude, information_desk_property.latitude]\n                },\n                properties: {\n                  type: information_desk_property.type,\n                  id: information_desk_property.id\n                }\n              });\n            }\n          });\n          informationDeskSource.setData(informationDesks);\n        }\n\n        const pointsReferenceSource = this.map.getSource('points-reference');\n\n        if (pointsReferenceSource && this.currentTrek.properties.points_reference && this.currentTrek.properties.points_reference.length > 0) {\n          const pointsReference = {\n            type: 'FeatureCollection',\n            features: []\n          };\n          this.currentTrek.properties.points_reference.forEach((point_reference, index) => {\n            pointsReference.features.push({\n              type: 'Feature',\n              geometry: {\n                type: 'Point',\n                coordinates: [point_reference[0], point_reference[1]]\n              },\n              properties: {\n                index: index + 1\n              }\n            });\n          });\n          pointsReferenceSource.setData(pointsReference);\n        }\n\n        const childrenTreksSource = this.map.getSource('children-treks');\n\n        if (childrenTreksSource && this.currentTrek.properties.children && this.currentTrek.properties.children.features.length > 0) {\n          const childrenTreks = Object.assign({}, this.currentTrek.properties.children);\n          childrenTreks.features.forEach((children, index) => {\n            if (children.properties) {\n              children.properties.index = index + 1;\n            }\n          });\n          childrenTreksSource.setData(childrenTreks);\n        }\n      }\n    }\n\n    flyToUserLocation() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const userLocation = yield this.geolocate.getCurrentPosition();\n\n        if (userLocation) {\n          const coordinates = [userLocation.longitude, userLocation.latitude];\n\n          if (this.markerPosition) {\n            this.markerPosition.setLngLat(coordinates);\n          } else {\n            const el = document.createElement('div');\n            const currentHeading = yield this.geolocate.checkIfCanGetCurrentHeading();\n            el.className = currentHeading ? 'pulse-and-view' : 'pulse';\n            this.markerPosition = new mapboxgl.Marker({\n              element: el\n            }).setLngLat(coordinates);\n\n            if (this.markerPosition) {\n              this.markerPosition.addTo(this.map);\n            }\n          }\n\n          this.map.flyTo({\n            center: coordinates,\n            animate: false,\n            zoom: environment.trekZoom.zoom\n          });\n        } else {\n          const errorTranslation = yield this.translate.get('geolocate.error').toPromise();\n          const alertLocation = yield this.alertController.create({\n            header: errorTranslation['header'],\n            subHeader: errorTranslation['subHeader'],\n            message: errorTranslation['message'],\n            buttons: [errorTranslation['confirmButton']]\n          });\n          yield alertLocation.present();\n        }\n      });\n    }\n\n    FitToTrekBounds() {\n      this.map.fitBounds(this.mapConfig.trekBounds, environment.map.TrekfitBoundsOptions);\n    }\n\n    showLayersVisibility(event) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const layers = [{\n          name: yield this.translate.get('trek.details.poi.name').toPromise(),\n          visibility: this.map.getLayoutProperty('pois-icon', 'visibility') === 'visible',\n          layersName: ['pois-icon', 'cluster-text-count-pois', 'clusters-circle-pois'].toString()\n        }, {\n          name: yield this.translate.get('trek.details.touristicContent.name').toPromise(),\n          visibility: this.map.getLayoutProperty('touristics-content-circle', 'visibility') === 'visible',\n          layersName: ['touristics-content-circle', 'touristics-content-icon', 'cluster-text-count-touristics-content', 'clusters-circle-touristics-content'].toString()\n        }];\n        const popover = yield this.popoverController.create({\n          component: LayersVisibilityComponent,\n          event: event,\n          translucent: true,\n          componentProps: {\n            changeLayerVisibility: (checked, layersName) => this.changeLayerVisibility(checked, layersName),\n            layers\n          }\n        });\n        return yield popover.present();\n      });\n    }\n\n    changeLayerVisibility(checked, layersName) {\n      layersName.split(',').forEach(layerName => this.map.setLayoutProperty(layerName, 'visibility', checked ? 'visible' : 'none'));\n    }\n\n    handleClustersInteraction() {\n      [{\n        id: 'pois',\n        translateId: 'trek.details.poi.name'\n      }, {\n        id: 'touristics-content',\n        translateId: 'trek.details.touristicContent.name'\n      }].forEach(clusterSource => {\n        this.map.on('click', `clusters-circle-${clusterSource.id}`, e => {\n          const features = this.map.queryRenderedFeatures(e.point, {\n            layers: [`clusters-circle-${clusterSource.id}`]\n          });\n          const featureProperties = features[0].properties;\n\n          if (!!featureProperties) {\n            const clusterId = featureProperties.cluster_id;\n\n            if (this.map.getZoom() === this.mapConfig.maxZoom) {\n              this.map.getSource(clusterSource.id).getClusterLeaves(featureProperties.cluster_id, Infinity, 0, (err, featuresInCluster) => {\n                if (err) {\n                  throw err;\n                }\n\n                this.presentConfirmFeatures(featuresInCluster, clusterSource);\n              });\n            } else {\n              this.map.getSource(clusterSource.id).getClusterExpansionZoom(clusterId, (err, zoom) => {\n                if (err) {\n                  return;\n                }\n\n                const coordinates = features[0].geometry.coordinates;\n                this.map.easeTo({\n                  center: [coordinates[0], coordinates[1]],\n                  zoom: zoom\n                });\n              });\n            }\n          }\n        });\n      });\n    }\n\n    presentConfirmFeatures(features, clusterSource) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const radioPois = [];\n\n        if (clusterSource.id === 'pois') {} else {}\n\n        features.forEach(feature => {\n          let currentType;\n\n          if (this.poisType && feature.properties.type && clusterSource.id === 'pois') {\n            currentType = this.poisType.values.find(poiType => poiType.id === feature.properties.type);\n          } else if (this.touristicsContentCategory && feature.properties.category && clusterSource.id === 'touristics-content') {\n            currentType = this.touristicsContentCategory.values.find(category => category.id === feature.properties.category);\n          }\n\n          const poi = {\n            id: feature.properties.id,\n            name: feature.properties.name,\n            imgTypePoi: {\n              src: currentType && currentType.pictogram ? currentType.pictogram : undefined,\n              color: currentType && currentType.color ? currentType.color : undefined\n            }\n          };\n          radioPois.push(poi);\n        });\n        const modal = yield this.modalController.create({\n          component: SelectPoiComponent,\n          componentProps: {\n            radioPois,\n            themePois: clusterSource.translateId\n          },\n          cssClass: 'full-size'\n        });\n        yield modal.present();\n        const {\n          data\n        } = yield modal.onDidDismiss();\n\n        if (data && data.selectedPoiId) {\n          const selectedFeature = features.find(feature => feature.properties.id === data.selectedPoiId);\n\n          if (selectedFeature) {\n            this.presentPoiDetails.emit(selectedFeature);\n          }\n        }\n      });\n    }\n\n    handleNavigateMode() {\n      return __awaiter(this, void 0, void 0, function* () {\n        this.navigateModeIsActive = !this.navigateModeIsActive;\n\n        if (this.navigateModeIsActive) {\n          const userLocation = yield this.geolocate.getCurrentPosition();\n\n          if (userLocation) {\n            this.map.flyTo({\n              center: [userLocation.longitude, userLocation.latitude],\n              animate: false,\n              zoom: environment.trekZoom.maxZoom\n            });\n            this.navigate$ = this.geolocate.currentPosition$.subscribe(coordinates => __awaiter(this, void 0, void 0, function* () {\n              if (coordinates) {\n                this.map.panTo(coordinates);\n              }\n            }));\n            this.map.dragPan.disable();\n          } else {\n            const errorTranslation = yield this.translate.get('geolocate.error').toPromise();\n            const alertLocation = yield this.alertController.create({\n              header: errorTranslation['header'],\n              subHeader: errorTranslation['subHeader'],\n              message: errorTranslation['message'],\n              buttons: [errorTranslation['confirmButton']]\n            });\n            yield alertLocation.present();\n          }\n        } else {\n          if (this.navigate$) {\n            this.navigate$.unsubscribe();\n          }\n\n          this.map.dragPan.enable();\n        }\n      });\n    }\n\n    presentInAppDisclosure() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const modal = yield this.modalController.create({\n          component: InAppDisclosureComponent,\n          componentProps: {},\n          cssClass: 'full-size'\n        });\n        yield modal.present();\n        yield modal.onDidDismiss();\n      });\n    }\n\n  }\n\n  MapTrekVizComponent.ɵfac = function MapTrekVizComponent_Factory(t) {\n    return new (t || MapTrekVizComponent)(i0.ɵɵdirectiveInject(i1.SettingsService), i0.ɵɵdirectiveInject(i2.GeolocateService), i0.ɵɵdirectiveInject(i3.PopoverController), i0.ɵɵdirectiveInject(i4.TranslateService), i0.ɵɵdirectiveInject(i3.AlertController), i0.ɵɵdirectiveInject(i3.ModalController), i0.ɵɵdirectiveInject(i5.OfflineTreksService));\n  };\n\n  MapTrekVizComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MapTrekVizComponent,\n    selectors: [[\"app-map-trek-viz\"]],\n    viewQuery: function MapTrekVizComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mapViz = _t.first);\n      }\n    },\n    inputs: {\n      currentTrek: \"currentTrek\",\n      currentPois: \"currentPois\",\n      touristicCategoriesWithFeatures: \"touristicCategoriesWithFeatures\",\n      dataSettings: \"dataSettings\",\n      mapConfig: \"mapConfig\",\n      commonSrc: \"commonSrc\",\n      offline: \"offline\"\n    },\n    outputs: {\n      presentPoiDetails: \"presentPoiDetails\",\n      presentInformationDeskDetails: \"presentInformationDeskDetails\",\n      navigateToChildren: \"navigateToChildren\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 11,\n    vars: 1,\n    consts: [[\"id\", \"map-trek\", 1, \"map-viz\"], [\"mapViz\", \"\"], [1, \"options-button-container\"], [\"shape\", \"round\", \"size\", \"small\", \"color\", \"light\", 3, \"click\"], [\"name\", \"navigate\", 3, \"color\"], [\"color\", \"dark\", \"name\", \"locate\"], [\"color\", \"dark\", \"name\", \"contract\"], [\"mode\", \"ios\", \"color\", \"dark\", \"name\", \"apps\"]],\n    template: function MapTrekVizComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n        i0.ɵɵelementStart(2, \"div\", 2)(3, \"ion-button\", 3);\n        i0.ɵɵlistener(\"click\", function MapTrekVizComponent_Template_ion_button_click_3_listener() {\n          return ctx.handleNavigateMode();\n        });\n        i0.ɵɵelement(4, \"ion-icon\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"ion-button\", 3);\n        i0.ɵɵlistener(\"click\", function MapTrekVizComponent_Template_ion_button_click_5_listener() {\n          return ctx.flyToUserLocation();\n        });\n        i0.ɵɵelement(6, \"ion-icon\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"ion-button\", 3);\n        i0.ɵɵlistener(\"click\", function MapTrekVizComponent_Template_ion_button_click_7_listener() {\n          return ctx.FitToTrekBounds();\n        });\n        i0.ɵɵelement(8, \"ion-icon\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(9, \"ion-button\", 3);\n        i0.ɵɵlistener(\"click\", function MapTrekVizComponent_Template_ion_button_click_9_listener($event) {\n          return ctx.showLayersVisibility($event);\n        });\n        i0.ɵɵelement(10, \"ion-icon\", 7);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"color\", !ctx.navigateModeIsActive ? \"dark\" : \"tertiary\");\n      }\n    },\n    directives: [i3.IonButton, i3.IonIcon],\n    styles: [\".options-button-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:absolute;right:24px;top:24px;z-index:5}\"]\n  });\n  return MapTrekVizComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}